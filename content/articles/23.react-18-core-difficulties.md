---
title: React 18 核心重难点
description: 最近在做了一些 Next.js 的实践之后，逐渐对 React 内部的具体实现起了兴趣，想从源码的角度具体地理解一下 React 的一些核心概念，以及它们到底是怎么实现的。
cover: /covers/23.webp
alt: React 18 核心重难点
ogImage: /covers/23.webp
tags: [React, 前端]
category: React Notes
publishedAt: 2024-10-15 01:10:21
editedAt: 2024-10-15 01:10:21
published: true
wordCount: 3271
---

最近在做了一些 Next.js 的实践之后，逐渐对 React 内部的具体实现起了兴趣，想从源码的角度具体地理解一下 React 的一些核心概念，以及它们到底是怎么实现的。

## React 重难点分类

### **Fiber 架构**

React 16 及以后的版本引入了全新的 Fiber 架构，它是 React 内部管理 UI 渲染的核心机制。理解 Fiber 是深入 React 的关键。主要难点包括：

- **可中断渲染**：Fiber 允许 React 将工作切分成可中断的任务。由于任务可以被暂停、恢复或者丢弃，这使得 UI 渲染变得更加高效，但也导致了调度机制的复杂性。
- **协调算法**：在 Fiber 中，调和（reconciliation）是核心，涉及到如何对比新的 VDOM 和旧的 VDOM。这一过程需要掌握 Fiber Node 的结构和优先级调度。
- **更新优先级**：Fiber 通过优先级调度更新，不同的更新任务有不同的优先级。了解 React 如何管理这些优先级（如同步任务、异步任务等）是难点之一。

### **Concurrent Mode（并发模式）**

并发模式是 React 未来的核心，它带来了异步渲染的能力，允许应用程序在等待高优先级任务完成时继续渲染其他内容。主要难点有：

- **Suspense**：理解 Suspense 的工作原理，尤其是如何与数据加载、异步组件相结合是学习 React 17 和 React 18 的重点。Suspense 与 Concurrent Mode 配合使用，使得应用在不阻塞主线程的情况下保持流畅。
- **调度器（Scheduler）**：Concurrent Mode 下，React 的调度器根据任务的优先级去执行工作单元。调度器的设计是为了保持应用的响应能力，这涉及到 React 的 `Scheduler` API 如何管理任务队列。

### **Hooks**

React Hooks 重新定义了组件的状态管理方式。虽然 Hooks 的使用非常简单，但是它背后的机制较为复杂。难点在于：

- **闭包陷阱**：Hooks 与 JavaScript 的闭包紧密相连，如果不理解闭包，可能会导致常见的陷阱，特别是在 `useEffect` 中。
- **Hook 调用规则**：Hooks 在函数组件中的调用有严格的规则，比如必须在顶层调用，不能在条件语句中使用。这一设计的原因与 React 的渲染机制有紧密关系。
- **useEffect 的依赖管理**：管理 `useEffect` 的依赖是 Hooks 使用中的难点之一，尤其是在依赖项数组未正确处理时，容易导致渲染错误或不必要的副作用。

### **Reconciliation（协调）机制**

React 的核心之一就是如何高效地更新 UI。它的 Diff 算法与传统的虚拟 DOM 差异化更新有着深度优化。难点包括：

- **双端比较算法**：理解 React 是如何通过最小代价更新 DOM 的，尤其是 Fiber 中的双端比较机制、子节点的删除、插入等操作。
- **Key 的作用**：React 中 `key` 属性的重要性不言而喻，它在调和中决定了组件的复用和重绘机制。理解 `key` 在 Fiber 节点链表中的位置很重要。

### **Server Components（服务器端组件）**

React 最新的功能之一是 Server Components，它允许在服务器端执行一些组件的逻辑，减轻客户端的负担。要深入理解这部分内容，需要掌握：

- **组件的分层执行**：了解哪些部分在服务端执行，哪些部分在客户端执行，是理解 React 最新性能优化方向的关键。
- **与 Suspense 的结合**：Server Components 依赖 Suspense 来控制组件渲染时机，尤其是在异步数据的处理上，需要理解如何协调这些机制。

### **渐进增强与 SSR/SSG**

React 当前的发展方向非常注重性能优化，尤其是在结合 SSR（服务端渲染）和 SSG（静态站点生成）时的渐进增强策略。难点在于：

- **SSR/SSG 的同构渲染**：服务端渲染与客户端渲染的结合部分，尤其是如何无缝地切换状态与事件处理，这是 Next.js 等框架的关键之一。
- **Hydration**：React 的 `hydrate` 机制允许 React 在服务端渲染后接管 HTML，理解这个过程中状态的同步以及事件绑定，是 SSR 中的重要环节。

## React 知识体系架构图

知识架构图不仅能帮助我们系统性地整理知识点，还能梳理出各个知识点之间的联系和脉络。

### React 知识体系架构图模块设计

1. **基础模块**

   - **Virtual DOM**：了解虚拟 DOM 的原理、作用和与真实 DOM 的对比。
   - **JSX**：JSX 是 React 的语法糖，理解它的解析过程，如何被转化为 `React.createElement`。

2. **Fiber 架构（核心）**

   - **Fiber Tree**：Fiber 节点的结构，如何通过链表结构构建虚拟 DOM。
   - **调度机制**：任务分片、优先级调度、任务暂停和恢复（中断渲染）。
   - **协调算法**：调和过程（Reconciliation）与双端比较，key 的作用。
   - **更新流程**：工作循环、commit 阶段的 UI 更新。

3. **Concurrent Mode**

   - **并发渲染**：如何通过并发模式实现渲染任务的可中断性。
   - **Scheduler**：调度器的任务管理及优先级的设计。
   - **Suspense**：异步数据加载的核心组件，如何与 Concurrent Mode 协作。

4. **Hooks**

   - **useState 与 useEffect**：Hooks 的基本原理、闭包问题、依赖数组的处理。
   - **自定义 Hook**：如何抽象逻辑，复用状态管理和副作用。
   - **React 内部 Hook**：React 是如何通过 Hook 机制管理组件状态的。

5. **高阶机制**

   - **Context API**：跨组件传递数据的机制，如何在深层组件中消费状态。
   - **React.memo 与 useMemo**：避免不必要的重新渲染。
   - **React.lazy 与 Suspense**：代码拆分与动态加载机制。

6. **Server Components**

   - **客户端与服务端的任务分工**：理解哪些逻辑在服务端执行，哪些在客户端执行。
   - **SSR/SSG 渲染机制**：结合框架（如 Next.js）进行服务端渲染和静态站点生成。
   - **Hydration**：服务端渲染后的页面重建过程，如何从静态 HTML 过渡到动态 React 应用。

7. **调优与性能优化**
   - **React 性能监控工具**：如何使用 Profiler 等工具分析组件性能。
   - **优化渲染**：如何利用 React 的架构进行性能优化，如使用 React.memo 避免重复渲染、拆分组件。
   - **渐进增强**：结合 SSR 与 SSG，提升加载和用户交互性能。

### 架构图连缀的逻辑

1. **基础模块**作为整个 React 的起点，可以理解为框架的根基。
2. **Fiber 架构**是 React 的核心，负责整个组件树的更新和渲染。它与 **Concurrent Mode** 紧密相关，负责高效渲染和调度。
3. **Concurrent Mode** 和 **Scheduler** 是实现并发渲染的关键，它们依赖于 **Fiber** 的基础结构，协调 React 的更新和渲染。
4. **Hooks** 是现代 React 状态管理的核心模块，贯穿于组件的整个生命周期。Hooks 通过 **Fiber** 管理状态和副作用，帮助开发者以函数式编程的方式编写组件。
5. **Server Components** 模块则与 Fiber 的渲染流程相关，结合 **SSR/SSG** 实现服务端和客户端的同构渲染。
6. **调优与性能优化** 是架构的高阶部分，它通过剖析 Fiber 的调度机制、Concurrent Mode 的渲染模式，帮助提升应用性能。

## 和 Vue.js 的一些对比

首先得明确，React 的定位 **不是框架**，而是一个 **库**。React 专注于构建用户界面，而 Vue.js 则是一个渐进式框架，提供了更多的功能和约定。它们的设计理念和核心机制有不少不同之处。

根据我自己在使用上的理解，它们的 **核心区别** 主要体现在 **设计哲学、框架的灵活性与可扩展性**、以及 **响应式机制** 等方面。

### **设计哲学**

- **React：函数式编程范式**

  - React 更加偏向函数式编程的理念，倡导使用不可变数据和纯函数来构建 UI。组件在 React 中是纯函数的概念，组件的状态和副作用使用 `useState` 和 `useEffect` 等 Hooks 进行管理。React 强调 **单向数据流**，通过状态驱动 UI 渲染。
  - **JSX** 是 React 的标志性特性。它将模板、逻辑和 CSS 融合在一起，鼓励在 JavaScript 中一切皆是组件和逻辑，并将视图层表达为 JavaScript 代码。

- **Vue：渐进式框架**
  - Vue 更加灵活，它允许逐步采用框架的不同特性，提供了更加 **面向对象的编程体验**。Vue 的组件系统基于 SFC（单文件组件），将 HTML、CSS 和 JavaScript 逻辑分离，具有更明确的分层结构，符合传统的 **模板与逻辑分离** 的思想。
  - Vue 以 **双向数据绑定** 著称，这一特性在表单处理上尤为方便。Vue 同时也支持单向数据流，但默认提供了简化的绑定方式。

### **响应式机制**

- **React：状态驱动渲染**

  - React 的核心是 **Virtual DOM**，通过 `setState` 或 `useState` 触发组件状态变更，整个组件会重新渲染，并通过虚拟 DOM 的 diff 算法去更新真实 DOM。React 的这种更新方式强调“重新渲染整个组件树”，而不直接修改现有 DOM 元素，这让它更加函数式。
  - React 的更新机制依赖 **不可变数据**，每次状态更新时需要返回一个新的状态对象，以此来触发重新渲染。

- **Vue：基于 Proxy 的响应式系统**
  - Vue 使用了 **响应式系统**，通过 `Proxy` 实现数据的响应式追踪，依赖收集和数据变更时的通知是 Vue 的核心特性。当数据发生变化时，Vue 会自动追踪依赖的组件或指令，精准更新视图层。这使得 Vue 在处理复杂的应用状态时，显得更加高效，因为它只更新需要更新的部分。
  - Vue 的响应式系统较为“魔法化”，即通过 Vue 自身的机制帮助开发者管理依赖和更新，开发者只管自己的数据怎么变就行。而 React 更依赖开发者手动调用 `setState` 进行更新。

### **生态和扩展性**

- **React：库的灵活性**

  - React 本身定位为 **视图层库**，它只专注于 UI 构建。开发者需要结合诸如 React Router、Redux、Recoil、Zustand 等第三方库来构建完整的前端应用。React 的灵活性强，开发者可以自由选择不同的库进行集成，这使得它适合更复杂的、定制化需求高的项目。**也正是因此，其学习曲线相对较高、最佳实践需要开发者自行探索。**
  - React 的灵活性意味着它在构建复杂应用时非常强大，但开发者也需要负责框架的组装和最佳实践的落实。

- **Vue：框架的一体化**
  - Vue 是一个**渐进式框架**，它自带了路由（Vue Router）和状态管理库（Vuex/Pinia）等完整的工具链，Vue 的核心库之外提供了很多“官方方案”。因此，对于中小型项目，Vue 通过一体化的解决方案，可以快速上手并提供完整的开发体验。
  - Vue 的一体化工具链降低了开发者自行选择库的负担，同时也让 Vue 更适合快速开发和中小型项目。很多时候 Vue 本身都已经为你提供好了最佳实践，**最典型的例子比如 Nuxt.js，它的目录结构都已经固定了，你只需要按照规范来写代码即可。**

### **组件化方式**

- **React：JSX 和 Hooks**

  - React 采用 **JSX** 来编写 UI 逻辑，JSX 将 JavaScript 与 HTML 紧密结合，更加强调“在 JavaScript 中写视图”。
  - **Hooks** 是 React 的核心亮点之一。通过 Hooks，开发者可以在函数组件中优雅地管理状态和副作用，并且 Hooks 使得逻辑复用变得更简单和灵活。

- **Vue：模板与逻辑分离**
  - Vue 使用传统的 **模板语法** 来定义组件的视图层，并通过 `script` 来编写逻辑。Vue 提供了非常直观的 SFC（单文件组件），在 HTML 模板中通过 `v-model`、`v-for` 等指令进行双向绑定和事件处理。
  - Vue 的组件化方式较为直观，尤其适合初学者和开发者快速构建 UI，结构清晰且易于理解。

### **性能优化机制**

- **React：可中断的更新与并发模式**

  - React 通过 **Fiber 架构** 支持任务的可中断性。最新的 **Concurrent Mode** 让 React 具备了“异步渲染”的能力，可以中断低优先级的任务，给高优先级的任务让路，从而保持用户界面的流畅度。
  - React 的调度机制更复杂，但灵活性强，能很好地应对复杂的渲染需求。

- **Vue：响应式精准更新**
  - Vue 的响应式系统可以追踪依赖，实现精准更新，只重新渲染发生变化的部分，减少不必要的 DOM 更新。它没有 React 那种复杂的任务调度机制，但其基于 `Proxy` 的响应式机制在大多数情况下已经足够高效。
  - Vue 的响应式更新使得它在性能优化方面的工作量相对较小，开发者不用手动管理渲染细节。

### 总结

React 和 Vue 在设计理念、响应式机制、生态扩展性以及组件化方式等方面都有很大的不同：

- **React** 更加注重函数式编程、单向数据流和状态驱动的渲染，强调不可变数据和 Hooks 的使用，适合复杂的、大型项目。
- **Vue** 则以渐进式的框架设计和模板语法为核心，专注于易用性和简化开发流程，响应式系统精准更新视图，适合中小型项目和快速开发需求。

可以说，React 更像是一块“灵活的积木”，而 Vue 则是一个“一站式的解决方案”。

## 后记

之后或许会就 React Fiber 架构自己手动实现一个微型的 Demo。
